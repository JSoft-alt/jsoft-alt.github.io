<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Server Chat App (Discord Clone)</title>
    <!-- Load Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Load Babel for JSX compilation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Load Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, 
            onSnapshot, collection, query, where, getDocs, serverTimestamp, setLogLevel 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Expose Firebase functions globally for the Babel script to access
        window.firebase = {
            initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
            getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, 
            onSnapshot, collection, query, where, getDocs, serverTimestamp, setLogLevel
        };

        // Ensure global config variables are defined if not present (for non-Canvas environments)
        if (typeof __app_id === 'undefined') window.__app_id = 'default-app-id';
        if (typeof __firebase_config === 'undefined') window.__firebase_config = JSON.stringify({ /* mock config */ });
        if (typeof __initial_auth_token === 'undefined') window.__initial_auth_token = null;
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
    </style>
</head>
<body class="bg-gray-900 min-h-screen">

    <div id="root">
        <!-- React App will be rendered here -->
    </div>

    <script type="text/babel">
        // Import React essentials from global window object
        const { useState, useEffect, useCallback, useMemo, useRef } = React;
        const { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, serverTimestamp, setLogLevel } = window.firebase;
        
        // --- Global Variables (Read from global scope) ---
        const appId = window.__app_id;
        const firebaseConfig = JSON.parse(window.__firebase_config);
        const initialAuthToken = window.__initial_auth_token;

        // --- Utility Functions ---

        const getDmId = (userAId, userBId) => {
            const ids = [userAId, userBId].sort();
            return `${ids[0]}_${ids[1]}`;
        };

        /**
         * Helper component for displaying confirmation/alert messages instead of alert().
         */
        const ConfirmationMessage = ({ message, type = 'info', onClose }) => {
            const baseClasses = "fixed top-4 right-4 p-4 rounded-xl shadow-2xl z-50 text-white font-semibold transition-opacity duration-300";
            let typeClasses = '';

            switch (type) {
                case 'success':
                    typeClasses = 'bg-green-600';
                    break;
                case 'error':
                    typeClasses = 'bg-red-600';
                    break;
                case 'info':
                default:
                    typeClasses = 'bg-blue-600';
                    break;
            }

            useEffect(() => {
                const timer = setTimeout(onClose, 5000);
                return () => clearTimeout(timer);
            }, [onClose]);

            return (
                <div className={`${baseClasses} ${typeClasses}`}>
                    {message}
                    <button onClick={onClose} className="ml-4 font-bold opacity-75 hover:opacity-100">
                        &times;
                    </button>
                </div>
            );
        };


        // --- Firebase Setup and Authentication Hooks ---

        const useFirebase = () => {
            const [db, setDb] = useState(null);
            const [auth, setAuth] = useState(null);
            const [userId, setUserId] = useState(null);
            const [isAuthReady, setIsAuthReady] = useState(false);

            useEffect(() => {
                if (!firebaseConfig) {
                    console.error("Firebase config is missing.");
                    return;
                }

                setLogLevel('Debug');

                try {
                    const app = initializeApp(firebaseConfig);
                    const firestore = getFirestore(app);
                    const firebaseAuth = getAuth(app);

                    setDb(firestore);
                    setAuth(firebaseAuth);

                    const unsubscribe = onAuthStateChanged(firebaseAuth, async (user) => {
                        if (user) {
                            setUserId(user.uid);
                        } else {
                            try {
                                if (initialAuthToken) {
                                    await signInWithCustomToken(firebaseAuth, initialAuthToken);
                                } else {
                                    await signInAnonymously(firebaseAuth);
                                }
                            } catch (error) {
                                console.error("Firebase Auth initialization failed:", error);
                                setUserId(crypto.randomUUID()); 
                            }
                        }
                        setIsAuthReady(true);
                    });

                    return () => unsubscribe();
                } catch (error) {
                    console.error("Error initializing Firebase:", error);
                    setIsAuthReady(true);
                    setUserId(crypto.randomUUID());
                }
            }, []);

            return { db, auth, userId, isAuthReady };
        };

        // --- Main Application Component ---

        const App = () => {
            const { db, auth, userId, isAuthReady } = useFirebase();

            // Data States
            const [userProfile, setUserProfile] = useState(null);
            const [allProfiles, setAllProfiles] = useState({});
            const [serverMemberships, setServerMemberships] = useState([]); 
            const [servers, setServers] = useState([]);
            const [channels, setChannels] = useState([]); 
            const [categories, setCategories] = useState([]); 
            const [messages, setMessages] = useState([]);
            const [dmSessions, setDmSessions] = useState([]);
            
            // UI States
            const [currentServerId, setCurrentServerId] = useState('DMs'); 
            const [currentChannelId, setCurrentChannelId] = useState(null);
            const [currentChannelType, setCurrentChannelType] = useState('text'); 
            const [newMessageText, setNewMessageText] = useState('');
            const [showModal, setShowModal] = useState(null); 
            const [editCategory, setEditCategory] = useState(null);
            const [authMode, setAuthMode] = useState('login'); 
            const [isAppLoading, setIsAppLoading] = useState(true);
            const [notification, setNotification] = useState(null); 

            const PUBLIC_DATA_PATH = useMemo(() => `/artifacts/${appId}/public/data`, []);

            const showNotification = useCallback((message, type = 'info') => {
                setNotification({ message, type });
            }, []);
            
            // --- Data Fetching (Listeners) ---
            
            // 1. Listen for User Profile and All Profiles/Memberships
            useEffect(() => {
                if (!db || !userId || !isAuthReady) return;

                const profilesRef = collection(db, PUBLIC_DATA_PATH, 'user_profiles');
                const membershipsRef = collection(db, PUBLIC_DATA_PATH, 'server_memberships');
                const qMemberships = query(membershipsRef, where('userId', '==', userId));


                // All profiles (for DMs, user lookup)
                const unsubscribeProfiles = onSnapshot(profilesRef, (snapshot) => {
                    const newProfiles = {};
                    snapshot.docs.forEach(doc => {
                        newProfiles[doc.id] = { id: doc.id, ...doc.data() };
                    });
                    setAllProfiles(newProfiles);
                    setIsAppLoading(false);
                }, (error) => console.error("Error fetching profiles:", error));

                // User's server memberships
                const unsubscribeMemberships = onSnapshot(qMemberships, (snapshot) => {
                    const memberships = snapshot.docs.map(doc => doc.data().serverId);
                    setServerMemberships(memberships);
                }, (error) => console.error("Error fetching memberships:", error));

                const userProfileRef = doc(db, PUBLIC_DATA_PATH, 'user_profiles', userId);
                const unsubscribeUserProfile = onSnapshot(userProfileRef, (docSnap) => {
                    const profileData = docSnap.data();
                    if (docSnap.exists() && profileData?.username) {
                        setUserProfile(profileData);
                    } else {
                        setUserProfile(null);
                        setShowModal('login');
                    }
                }, (error) => console.error("Error fetching current user profile:", error));
                
                return () => {
                    unsubscribeProfiles();
                    unsubscribeMemberships();
                    unsubscribeUserProfile();
                };
            }, [db, userId, isAuthReady, PUBLIC_DATA_PATH]);

            // 2. Listen for User's Servers
            useEffect(() => {
                if (!db || serverMemberships.length === 0) {
                    setServers([]);
                    return;
                }

                const serversRef = collection(db, PUBLIC_DATA_PATH, 'servers');
                // Firestore doesn't allow 'in' query on empty array, but we guard against this above
                const qServers = query(serversRef, where('__name__', 'in', serverMemberships));

                const unsubscribeServers = onSnapshot(qServers, (snapshot) => {
                    const newServers = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setServers(newServers);
                    
                    // Set first server as active if DMs is not selected and current is invalid
                    if (currentServerId !== 'DMs' && !newServers.some(s => s.id === currentServerId)) {
                        setCurrentServerId(newServers[0]?.id || 'DMs');
                    }
                }, (error) => console.error("Error fetching servers:", error));

                return () => unsubscribeServers();
            }, [db, serverMemberships, currentServerId, PUBLIC_DATA_PATH]);


            // 3. Listen for Channels and Categories (Scoped to currentServerId)
            useEffect(() => {
                if (!db || !userProfile || currentServerId === 'DMs') {
                    setChannels([]);
                    setCategories([]);
                    return;
                }

                const categoriesRef = collection(db, PUBLIC_DATA_PATH, 'servers', currentServerId, 'categories');
                const unsubscribeCategories = onSnapshot(categoriesRef, (snapshot) => {
                    const newCategories = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
                                                        .sort((a, b) => (a.order || 0) - (b.order || 0));
                    setCategories(newCategories);
                });

                const channelsRef = collection(db, PUBLIC_DATA_PATH, 'servers', currentServerId, 'channels');
                const unsubscribeChannels = onSnapshot(channelsRef, (snapshot) => {
                    const newChannels = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setChannels(newChannels);
                    
                    // Set initial channel if none is selected
                    if (!currentChannelId || !newChannels.some(c => c.id === currentChannelId)) {
                        setCurrentChannelId(newChannels[0]?.id || null);
                        setCurrentChannelType('text');
                    }
                });

                return () => {
                    unsubscribeCategories();
                    unsubscribeChannels();
                };
            }, [db, userProfile, currentServerId, currentChannelId, PUBLIC_DATA_PATH]);


            // 4. Listen for DM Sessions
            useEffect(() => {
                if (!db || !userId || !userProfile) return;

                const dmsRef = collection(db, PUBLIC_DATA_PATH, 'dm_sessions');
                const q = query(dmsRef, where('participants', 'array-contains', userId));

                const unsubscribeDMs = onSnapshot(q, (snapshot) => {
                    const newDMSessions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setDmSessions(newDMSessions);
                }, (error) => console.error("Error fetching DM sessions:", error));

                return () => unsubscribeDMs();
            }, [db, userId, userProfile, PUBLIC_DATA_PATH]);


            // 5. Listen for Messages in the current Channel/DM
            useEffect(() => {
                if (!db || !currentChannelId || !userProfile) {
                    setMessages([]);
                    return;
                }

                let collectionRef;
                if (currentChannelType === 'dm') {
                    collectionRef = collection(db, PUBLIC_DATA_PATH, 'dm_messages', currentChannelId, 'messages');
                } else if (currentChannelType === 'text' && currentServerId !== 'DMs') {
                    collectionRef = collection(db, PUBLIC_DATA_PATH, 'servers', currentServerId, 'channels', currentChannelId, 'messages');
                } else {
                    setMessages([]);
                    return;
                }
                
                // Note: Not using orderBy() to avoid index requirement, sorting in memory instead
                const q = query(collectionRef); 

                const unsubscribeMessages = onSnapshot(q, (snapshot) => {
                    const newMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
                                                    .sort((a, b) => (a.timestamp?.toMillis() || 0) - (b.timestamp?.toMillis() || 0));
                    setMessages(newMessages);
                }, (error) => console.error("Error fetching messages:", error));

                return () => unsubscribeMessages();
            }, [db, currentChannelId, currentChannelType, currentServerId, userProfile, PUBLIC_DATA_PATH]);
            
            // --- Core Action Handlers ---
            
            const selectServer = useCallback((serverId) => {
                setCurrentServerId(serverId);
                setCurrentChannelId(null);
                setCurrentChannelType(serverId === 'DMs' ? 'dm' : 'text'); // Reset channel type based on server context
            }, []);

            const selectChannel = useCallback((id, type) => {
                setCurrentChannelId(id);
                setCurrentChannelType(type);
            }, []);

            // Server Deletion
            const handleDeleteServer = useCallback(async (serverId) => {
                if (!db || !userProfile) return;
                
                const currentServer = servers.find(s => s.id === serverId);
                if (currentServer.ownerId !== userId) {
                    showNotification('Only the server owner can delete this server.', 'error');
                    return;
                }
                
                // Simplified deletion for artifact demo (only server doc and memberships)
                try {
                    const serverRef = doc(db, PUBLIC_DATA_PATH, 'servers', serverId);
                    await deleteDoc(serverRef);

                    const membershipsRef = collection(db, PUBLIC_DATA_PATH, 'server_memberships');
                    const q = query(membershipsRef, where('serverId', '==', serverId));
                    const snapshot = await getDocs(q);
                    
                    for (const doc of snapshot.docs) {
                        await deleteDoc(doc.ref);
                    }

                    selectServer('DMs');
                    showNotification('Server and all associated memberships deleted.', 'success');
                } catch (error) {
                    console.error("Error deleting server:", error);
                    showNotification('Failed to delete server.', 'error');
                }
            }, [db, userId, userProfile, servers, selectServer, PUBLIC_DATA_PATH, showNotification]);

            // Channel Deletion
            const handleDeleteChannel = useCallback(async (channelId) => {
                if (!db || !currentServerId || currentServerId === 'DMs') return;

                try {
                    const channelRef = doc(db, PUBLIC_DATA_PATH, 'servers', currentServerId, 'channels', channelId);
                    await deleteDoc(channelRef);
                    
                    if (currentChannelId === channelId) {
                        setCurrentChannelId(null);
                        setMessages([]);
                    }

                    showNotification('Channel deleted successfully.', 'success');
                } catch (error) {
                    console.error("Error deleting channel:", error);
                    showNotification('Failed to delete channel.', 'error');
                }
            }, [db, currentServerId, currentChannelId, showNotification, PUBLIC_DATA_PATH]);

            // Message Deletion
            const deleteMessage = useCallback(async (messageId) => {
                if (!db || !currentChannelId || !userProfile) return;

                const messageToDelete = messages.find(m => m.id === messageId);
                if (!messageToDelete || messageToDelete.userId !== userId) {
                    showNotification('You can only delete your own messages.', 'error');
                    return;
                }

                const collectionPath = currentChannelType === 'dm'
                    ? `${PUBLIC_DATA_PATH}/dm_messages/${currentChannelId}/messages`
                    : `${PUBLIC_DATA_PATH}/servers/${currentServerId}/channels/${currentChannelId}/messages`;
                    
                const messageRef = doc(db, collectionPath, messageId);

                try {
                    await deleteDoc(messageRef);
                    showNotification('Message deleted successfully.', 'success');
                } catch (error) {
                    console.error("Error deleting message:", error);
                    showNotification('Failed to delete message. Check console for details.', 'error');
                }
            }, [db, currentChannelId, currentChannelType, currentServerId, userId, messages, userProfile, PUBLIC_DATA_PATH, showNotification]);

            const sendMessage = useCallback(async (e) => {
                e.preventDefault();
                if (!newMessageText.trim() || !userProfile || !currentChannelId || !db) return;

                let messagesRef;
                if (currentChannelType === 'dm') {
                    messagesRef = collection(db, PUBLIC_DATA_PATH, 'dm_messages', currentChannelId, 'messages');
                } else if (currentChannelType === 'text' && currentServerId !== 'DMs') {
                    messagesRef = collection(db, PUBLIC_DATA_PATH, 'servers', currentServerId, 'channels', currentChannelId, 'messages');
                } else {
                    showNotification("Cannot send message. Invalid channel or server selected.", 'error');
                    return;
                }

                try {
                    await addDoc(messagesRef, {
                        userId: userId,
                        text: newMessageText.trim(),
                        timestamp: serverTimestamp(),
                    });
                    setNewMessageText('');
                } catch (error) {
                    console.error("Error sending message:", error);
                    showNotification('Failed to send message.', 'error');
                }
            }, [db, userId, userProfile, currentChannelId, currentChannelType, currentServerId, newMessageText, PUBLIC_DATA_PATH, showNotification]);


            // Server Handlers
            const handleCreateServer = useCallback(async (serverName) => {
                if (!db || !userId || !serverName.trim()) return;

                try {
                    const serversRef = collection(db, PUBLIC_DATA_PATH, 'servers');
                    const newServerRef = await addDoc(serversRef, {
                        name: serverName.trim(),
                        ownerId: userId,
                        inviteCode: crypto.randomUUID().substring(0, 8).toUpperCase(), // Shortened UUID for code
                        createdAt: serverTimestamp(),
                    });

                    // Creator joins automatically
                    const membershipsRef = collection(db, PUBLIC_DATA_PATH, 'server_memberships');
                    await addDoc(membershipsRef, {
                        serverId: newServerRef.id,
                        userId: userId,
                        joinedAt: serverTimestamp(),
                    });
                    
                    selectServer(newServerRef.id);
                    setShowModal(null);
                    showNotification(`Server "${serverName}" created!`, 'success');

                } catch (error) {
                    console.error("Error creating server:", error);
                    showNotification('Failed to create server.', 'error');
                }
            }, [db, userId, selectServer, PUBLIC_DATA_PATH, showNotification]);
            
            const handleJoinServer = useCallback(async (inviteCode) => {
                if (!db || !userId || !inviteCode.trim()) return;

                try {
                    const serversRef = collection(db, PUBLIC_DATA_PATH, 'servers');
                    const q = query(serversRef, where('inviteCode', '==', inviteCode.trim().toUpperCase()));
                    const snapshot = await getDocs(q);

                    if (snapshot.empty) {
                        showNotification('Invalid invite code.', 'error');
                        return;
                    }

                    const serverDoc = snapshot.docs[0];
                    const serverIdToJoin = serverDoc.id;

                    if (serverMemberships.includes(serverIdToJoin)) {
                        showNotification('You are already a member of this server.', 'info');
                        selectServer(serverIdToJoin);
                        setShowModal(null);
                        return;
                    }

                    // Add user membership
                    const membershipsRef = collection(db, PUBLIC_DATA_PATH, 'server_memberships');
                    await addDoc(membershipsRef, {
                        serverId: serverIdToJoin,
                        userId: userId,
                        joinedAt: serverTimestamp(),
                    });

                    selectServer(serverIdToJoin);
                    setShowModal(null);
                    showNotification(`Joined server "${serverDoc.data().name}"!`, 'success');

                } catch (error) {
                    console.error("Error joining server:", error);
                    showNotification('Failed to join server.', 'error');
                }
            }, [db, userId, serverMemberships, selectServer, PUBLIC_DATA_PATH, showNotification]);

            // Category Handlers
            const openCategoryModal = (category = null) => {
                if (currentServerId === 'DMs') {
                    showNotification('Categories can only be managed within a server.', 'error');
                    return;
                }
                setEditCategory(category);
                setShowModal('category');
            };

            const handleSaveCategory = useCallback(async (name, order, id = null) => {
                if (!db || !name.trim() || currentServerId === 'DMs') return;

                const categoryData = { name: name.trim(), order: parseInt(order) || 0 };
                const categoriesPath = collection(db, PUBLIC_DATA_PATH, 'servers', currentServerId, 'categories');

                try {
                    if (id) {
                        const categoryRef = doc(categoriesPath, id);
                        await updateDoc(categoryRef, categoryData);
                    } else {
                        await addDoc(categoriesPath, categoryData);
                    }
                    setShowModal(null);
                    setEditCategory(null);
                    showNotification(id ? 'Category updated.' : 'Category created.', 'success');
                } catch (error) {
                    console.error("Error saving category:", error);
                    showNotification('Failed to save category.', 'error');
                }
            }, [db, currentServerId, PUBLIC_DATA_PATH, showNotification]);
            
            const handleDeleteCategory = useCallback(async (categoryId) => {
                if (!db || currentServerId === 'DMs') return;

                const channelsInCategory = channels.filter(c => c.categoryId === categoryId);
                if (channelsInCategory.length > 0) {
                    showNotification('Cannot delete category: Delete all associated channels first.', 'error');
                    return;
                }

                try {
                    const categoryRef = doc(db, PUBLIC_DATA_PATH, 'servers', currentServerId, 'categories', categoryId);
                    await deleteDoc(categoryRef);
                    setShowModal(null);
                    setEditCategory(null);
                    showNotification('Category deleted successfully.', 'success');
                } catch (error) {
                    console.error("Error deleting category:", error);
                    showNotification('Failed to delete category.', 'error');
                }
            }, [db, currentServerId, channels, PUBLIC_DATA_PATH, showNotification]);


            // Channel Handlers
            const handleSaveChannel = useCallback(async (name, categoryId) => {
                if (!db || !name.trim() || !categoryId || currentServerId === 'DMs') return;

                try {
                    const channelsRef = collection(db, PUBLIC_DATA_PATH, 'servers', currentServerId, 'channels');
                    await addDoc(channelsRef, {
                        name: name.trim(),
                        categoryId: categoryId,
                        type: 'text',
                        createdAt: serverTimestamp(),
                        creatorId: userId,
                    });
                    setShowModal(null);
                    showNotification('Channel created successfully.', 'success');
                } catch (error) {
                    console.error("Error creating channel:", error);
                    showNotification('Failed to create channel.', 'error');
                }
            }, [db, userId, currentServerId, PUBLIC_DATA_PATH, showNotification]);
            
            // DM Handlers
            const findProfileByUsername = useCallback((username) => {
                return Object.values(allProfiles).find(p => p.username?.toLowerCase() === username?.toLowerCase());
            }, [allProfiles]);

            const handleStartDm = useCallback(async (targetUsername) => {
                if (!db || !userId || !userProfile) return;
                
                const targetProfile = findProfileByUsername(targetUsername);

                if (!targetProfile) {
                    showNotification(`User "${targetUsername}" not found.`, 'error');
                    return;
                }
                
                const targetUserId = targetProfile.id;

                if (targetUserId === userId) {
                    showNotification("You cannot DM yourself.", 'info');
                    return;
                }

                const dmId = getDmId(userId, targetUserId);
                const dmRef = doc(db, PUBLIC_DATA_PATH, 'dm_sessions', dmId);

                try {
                    const dmSnap = await getDoc(dmRef);
                    if (!dmSnap.exists()) {
                        await setDoc(dmRef, {
                            participants: [userId, targetUserId],
                            createdAt: serverTimestamp(),
                        });
                    }
                    
                    selectServer('DMs'); 
                    selectChannel(dmId, 'dm');
                    setShowModal(null);
                    showNotification(`DM started with @${targetUsername}.`, 'success');
                } catch (error) {
                    console.error("Error starting DM:", error);
                    showNotification('Failed to start DM.', 'error');
                }
            }, [db, userId, userProfile, findProfileByUsername, selectServer, selectChannel, PUBLIC_DATA_PATH, showNotification]);

            // --- Memoized Data & Current Context ---

            const currentServer = useMemo(() => {
                if (currentServerId === 'DMs') {
                    return { id: 'DMs', name: 'Direct Messages', icon: 'ðŸ’¬' };
                }
                return servers.find(s => s.id === currentServerId);
            }, [currentServerId, servers]);

            const categorizedChannels = useMemo(() => {
                const groups = {};
                categories.forEach(cat => groups[cat.id] = { ...cat, channels: [] });

                channels.forEach(channel => {
                    const catId = channel.categoryId;
                    if (groups[catId]) {
                        groups[catId].channels.push(channel);
                    } else {
                        const uncategorizedId = 'uncategorized';
                        if (!groups[uncategorizedId]) {
                            groups[uncategorizedId] = { id: uncategorizedId, name: 'Uncategorized', order: 9999, channels: [] };
                        }
                        groups[uncategorizedId].channels.push(channel);
                    }
                });

                return Object.values(groups).sort((a, b) => (a.order || 9999) - (b.order || 9999));
            }, [channels, categories]);

            const currentChannel = useMemo(() => {
                if (!currentChannelId) return null;

                if (currentChannelType === 'dm') {
                    const session = dmSessions.find(s => s.id === currentChannelId);
                    if (!session) return null;
                    
                    const otherUserId = session.participants.find(id => id !== userId);
                    const otherProfile = allProfiles[otherUserId];

                    return {
                        id: currentChannelId,
                        name: otherProfile ? `@${otherProfile.displayName}` : 'DM Session',
                        type: 'dm',
                        participants: session.participants,
                    };
                } else {
                    return channels.find(c => c.id === currentChannelId);
                }
            }, [currentChannelId, currentChannelType, channels, dmSessions, userId, allProfiles]);

            // --- Component Rendering ---

            if (isAppLoading) {
                return (
                    <div className="flex items-center justify-center min-h-screen bg-gray-900 text-gray-200">
                        <p>Connecting to server and loading user session...</p>
                    </div>
                );
            }
            
            // Generic Modal Component
            const Modal = ({ children, title, onClose }) => (
                <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-xl shadow-2xl w-full max-w-md">
                        <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                            <h2 className="text-xl font-bold text-white">{title}</h2>
                            <button onClick={onClose} className="text-gray-400 hover:text-white transition">
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>
                        <div className="p-4">
                            {children}
                        </div>
                    </div>
                </div>
            );
            
            // Server Modals
            const CreateServerModal = () => {
                const [serverName, setServerName] = useState('');
                const handleSubmit = (e) => {
                    e.preventDefault();
                    handleCreateServer(serverName);
                };
                return (
                    <Modal title="Create a New Server" onClose={() => setShowModal(null)}>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <input
                                type="text"
                                placeholder="Server Name (e.g., My Dev Team)"
                                value={serverName}
                                onChange={(e) => setServerName(e.target.value)}
                                className="w-full p-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-purple-500 focus:border-purple-500"
                                required
                            />
                            <button type="submit" className="w-full py-2 bg-purple-600 text-white font-semibold rounded-lg hover:bg-purple-700 transition duration-150 shadow-md">
                                Create Server
                            </button>
                        </form>
                    </Modal>
                );
            };

            const JoinServerModal = () => {
                const [inviteCode, setInviteCode] = useState('');
                const handleSubmit = (e) => {
                    e.preventDefault();
                    handleJoinServer(inviteCode);
                };
                return (
                    <Modal title="Join Server via Invite Code" onClose={() => setShowModal(null)}>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <input
                                type="text"
                                placeholder="Invite Code (e.g., A1B2C3D4)"
                                value={inviteCode}
                                onChange={(e) => setInviteCode(e.target.value)}
                                className="w-full p-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-purple-500 focus:border-purple-500"
                                required
                            />
                            <button type="submit" className="w-full py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 transition duration-150 shadow-md">
                                Join Server
                            </button>
                        </form>
                    </Modal>
                );
            };
            
            // Channel/Category/DM Modals (Simplified for single file conversion)
            const ChannelModal = () => {
                const [name, setName] = useState('');
                const [categoryId, setCategoryId] = useState(categories[0]?.id || '');
                
                const handleSubmit = (e) => {
                    e.preventDefault();
                    handleSaveChannel(name, categoryId);
                };

                return (
                    <Modal title="Create New Channel" onClose={() => setShowModal(null)}>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <label className="block text-sm font-medium text-gray-300">Channel Name</label>
                            <input
                                type="text"
                                placeholder="e.g., general-chat"
                                value={name}
                                onChange={(e) => setName(e.target.value)}
                                className="w-full p-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-purple-500 focus:border-purple-500"
                                required
                            />
                            <label className="block text-sm font-medium text-gray-300">Category</label>
                            <select
                                value={categoryId}
                                onChange={(e) => setCategoryId(e.target.value)}
                                className="w-full p-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-purple-500 focus:border-purple-500"
                                required
                            >
                                {categories.map(cat => (
                                    <option key={cat.id} value={cat.id}>{cat.name}</option>
                                ))}
                            </select>
                            <button type="submit" className="w-full py-2 bg-purple-600 text-white font-semibold rounded-lg hover:bg-purple-700 transition duration-150 shadow-md">
                                Create Channel
                            </button>
                        </form>
                    </Modal>
                );
            };

            const CategoryModal = () => {
                const [name, setName] = useState(editCategory?.name || '');
                const [order, setOrder] = useState(editCategory?.order || 0);

                const handleSubmit = (e) => {
                    e.preventDefault();
                    handleSaveCategory(name, order, editCategory?.id);
                };
                
                const isDeleteDisabled = editCategory && channels.some(c => c.categoryId === editCategory.id);

                return (
                    <Modal title={editCategory ? 'Edit Category' : 'Create Category'} onClose={() => setShowModal(null)}>
                        <form onSubmit={handleSubmit} className="space-y-4 mb-4">
                            <input
                                type="text"
                                placeholder="Category Name (e.g., General, Dev)"
                                value={name}
                                onChange={(e) => setName(e.target.value)}
                                className="w-full p-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-purple-500 focus:border-purple-500"
                                required
                            />
                            <input
                                type="number"
                                placeholder="Order (Lower number appears first)"
                                value={order}
                                onChange={(e) => setOrder(e.target.value)}
                                className="w-full p-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-purple-500 focus:border-purple-500"
                                required
                            />
                            <button type="submit" className="w-full py-2 bg-purple-600 text-white font-semibold rounded-lg hover:bg-purple-700 transition duration-150 shadow-md">
                                {editCategory ? 'Save Changes' : 'Create Category'}
                            </button>
                        </form>
                        {editCategory && (
                            <button 
                                type="button" 
                                onClick={() => handleDeleteCategory(editCategory.id)}
                                className={`w-full py-2 font-semibold rounded-lg transition duration-150 shadow-md ${isDeleteDisabled ? 'bg-gray-500 text-gray-300 cursor-not-allowed' : 'bg-red-600 hover:bg-red-700 text-white'}`}
                                disabled={isDeleteDisabled}
                                title={isDeleteDisabled ? "Delete associated channels first" : "Delete this category"}
                            >
                                Delete Category
                            </button>
                        )}
                    </Modal>
                );
            };

            const StartDmModal = () => {
                const [targetUsername, setTargetUsername] = useState('');
                const handleSubmit = (e) => {
                    e.preventDefault();
                    if (targetUsername.trim()) {
                        handleStartDm(targetUsername.trim());
                        setTargetUsername('');
                    }
                };

                return (
                    <Modal title="Start Direct Message" onClose={() => setShowModal(null)}>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <p className="text-sm text-gray-400">Enter the username of the user you want to chat with.</p>
                            <input
                                type="text"
                                placeholder="Target Username"
                                value={targetUsername}
                                onChange={(e) => setTargetUsername(e.target.value)}
                                className="w-full p-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-purple-500 focus:border-purple-500"
                                required
                            />
                            <button type="submit" className="w-full py-2 bg-purple-600 text-white font-semibold rounded-lg hover:bg-purple-700 transition duration-150 shadow-md">
                                Start DM
                            </button>
                        </form>
                    </Modal>
                );
            };
            
            const AuthModal = () => {
                const [username, setUsername] = useState('');
                const [password, setPassword] = useState('');
                
                const handleAuth = async (username, password) => {
                    if (!db || !auth || !userId) return;
            
                    const credentialsRef = collection(db, PUBLIC_DATA_PATH, 'user_credentials');
                    const userCredQuery = query(credentialsRef, where('username', '==', username));
            
                    try {
                        const snapshot = await getDocs(userCredQuery);
                        const userCredDoc = snapshot.docs[0];
            
                        if (authMode === 'signup') {
                            if (userCredDoc) {
                                showNotification('Username already taken.', 'error');
                                return;
                            }
                            
                            await addDoc(credentialsRef, {
                                username: username,
                                password: password, 
                                userId: userId, 
                            });
            
                            await setDoc(doc(db, PUBLIC_DATA_PATH, 'user_profiles', userId), {
                                username: username,
                                displayName: username,
                                status: 'online',
                            });
                            
                            showNotification('Signup successful. You are now logged in!', 'success');
            
                        } else { 
                            if (!userCredDoc || userCredDoc.data().password !== password) {
                                showNotification('Invalid username or password.', 'error');
                                return;
                            }
            
                            showNotification('Login successful!', 'success');
                        }
                        setShowModal(null);
                        
                    } catch (error) {
                        console.error("Auth error:", error);
                        showNotification(`Authentication failed: ${error.message}`, 'error');
                    }
                };

                const handleSubmit = (e) => {
                    e.preventDefault();
                    if (username.trim() && password.trim()) {
                        handleAuth(username.trim(), password.trim());
                    }
                };

                return (
                    <Modal title={authMode === 'login' ? 'Login' : 'Sign Up'} onClose={() => {
                        setShowModal(null);
                        if (!userProfile) { auth.signOut().then(() => signInAnonymously(auth)); }
                    }}>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <input
                                type="text"
                                placeholder="Username"
                                value={username}
                                onChange={(e) => setUsername(e.target.value)}
                                className="w-full p-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-purple-500 focus:border-purple-500"
                                required
                            />
                            <input
                                type="password"
                                placeholder="Password"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                className="w-full p-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-purple-500 focus:border-purple-500"
                                required
                            />
                            <button type="submit" className="w-full py-2 bg-purple-600 text-white font-semibold rounded-lg hover:bg-purple-700 transition duration-150 shadow-md">
                                {authMode === 'login' ? 'Login' : 'Sign Up'}
                            </button>
                        </form>
                        <div className="mt-4 text-center">
                            <button 
                                onClick={() => setAuthMode(authMode === 'login' ? 'signup' : 'login')}
                                className="text-sm text-purple-400 hover:text-purple-300 transition"
                            >
                                {authMode === 'login' ? 'Need an account? Sign up' : 'Already have an account? Login'}
                            </button>
                        </div>
                    </Modal>
                );
            };

            const ProfileModal = () => {
                const [newDisplayName, setNewDisplayName] = useState(userProfile?.displayName || '');
                const [newUsername, setNewUsername] = useState(userProfile?.username || '');

                const handleUpdateProfile = useCallback(async (newUsername, newDisplayName) => {
                    if (!db || !userId || !userProfile) return;
                    const profileRef = doc(db, PUBLIC_DATA_PATH, 'user_profiles', userId);
                    const credentialsRef = collection(db, PUBLIC_DATA_PATH, 'user_credentials');
                    let credentialDocId = null;
            
                    try {
                        const q = query(credentialsRef, where('userId', '==', userId));
                        const snapshot = await getDocs(q);
                        if (!snapshot.empty) { credentialDocId = snapshot.docs[0].id; } else { showNotification('Could not find linked credential record.', 'error'); return; }
            
                        if (newUsername !== userProfile.username) {
                            const usernameCheckQuery = query(credentialsRef, where('username', '==', newUsername));
                            const checkSnapshot = await getDocs(usernameCheckQuery);
                            if (!checkSnapshot.empty) { showNotification('Username is already taken.', 'error'); return; }
            
                            const credentialDocRef = doc(db, PUBLIC_DATA_PATH, 'user_credentials', credentialDocId);
                            await updateDoc(credentialDocRef, { username: newUsername });
                        }
            
                        await updateDoc(profileRef, { displayName: newDisplayName.trim(), username: newUsername.trim() });
            
                        showNotification('Profile updated successfully!', 'success');
                        setShowModal(null);
            
                    } catch (error) {
                        console.error("Error updating profile:", error);
                        showNotification(`Error updating profile: ${error.message}`, 'error');
                    }
                }, [db, userId, userProfile, PUBLIC_DATA_PATH, showNotification]);

                const handleSubmit = (e) => {
                    e.preventDefault();
                    if (newDisplayName.trim() && newUsername.trim()) {
                        handleUpdateProfile(newUsername.trim(), newDisplayName.trim());
                    } else {
                        showNotification('Username and Display Name cannot be empty.', 'error');
                    }
                };

                return (
                    <Modal title="Edit Profile" onClose={() => setShowModal(null)}>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <p className="text-sm text-gray-400">
                                Firebase ID: <span className="font-mono text-xs text-gray-500">{userId}</span>
                            </p>
                            <label className="block text-sm font-medium text-gray-300">Display Name (Public)</label>
                            <input
                                type="text"
                                placeholder="New Display Name"
                                value={newDisplayName}
                                onChange={(e) => setNewDisplayName(e.target.value)}
                                className="w-full p-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-purple-500 focus:border-purple-500"
                                required
                            />
                            <label className="block text-sm font-medium text-gray-300">Username (Login ID)</label>
                            <input
                                type="text"
                                placeholder="New Username"
                                value={newUsername}
                                onChange={(e) => setNewUsername(e.target.value)}
                                className="w-full p-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-purple-500 focus:border-purple-500"
                                required
                            />
                            <button type="submit" className="w-full py-2 bg-purple-600 text-white font-semibold rounded-lg hover:bg-purple-700 transition duration-150 shadow-md">
                                Save Profile
                            </button>
                        </form>
                    </Modal>
                );
            };

            // Server Item Component (with 3-second hover delay)
            const ServerItem = ({ id, name, isSelected, onClick, onDelete, isOwner, inviteCode, handleDeleteServer }) => {
                const initial = id === 'DMs' ? 'DM' : name.substring(0, 2).toUpperCase();
                const [showOptions, setShowOptions] = useState(false);
                const hoverTimeoutRef = useRef(null);

                // --- Hover Delay Logic ---
                const handleMouseEnter = () => {
                    // Clear any existing timer to keep it visible instantly
                    if (hoverTimeoutRef.current) {
                        clearTimeout(hoverTimeoutRef.current);
                        hoverTimeoutRef.current = null;
                    }
                    setShowOptions(true);
                };

                const handleMouseLeave = () => {
                    // Start the 3-second timer before hiding
                    hoverTimeoutRef.current = setTimeout(() => {
                        setShowOptions(false);
                        hoverTimeoutRef.current = null;
                    }, 3000); 
                };
                // --------------------------
                
                // Popover classes controlled by showOptions state
                const popoverClasses = showOptions 
                    ? 'opacity-100 pointer-events-auto' 
                    : 'opacity-0 pointer-events-none';

                return (
                    <div 
                        className="relative"
                        onMouseEnter={handleMouseEnter}
                        onMouseLeave={handleMouseLeave}
                    >
                        <button
                            onClick={() => onClick(id)}
                            title={name}
                            className={`
                                w-14 h-14 mb-2 flex items-center justify-center text-white text-lg font-bold 
                                rounded-2xl transition-all duration-200 
                                ${isSelected ? 'bg-purple-600 rounded-3xl ring-4 ring-white' : 'bg-gray-700 hover:bg-purple-600 hover:rounded-2xl'}
                            `}
                        >
                            {initial}
                        </button>
                        
                        {/* Server Options Popover */}
                        {id !== 'DMs' && (
                            <div className={`
                                absolute top-1/2 left-16 transform -translate-y-1/2 bg-gray-900 border border-gray-700 p-2 rounded-lg shadow-xl w-48 space-y-1 transition duration-300 
                                ${popoverClasses}
                            `}>
                                <p className="text-sm font-semibold text-white truncate">{name}</p>
                                <button 
                                    onClick={() => { navigator.clipboard.writeText(inviteCode); showNotification('Invite code copied!', 'info'); }}
                                    className="w-full text-left text-xs text-green-400 hover:text-green-300 transition"
                                >
                                    ðŸ”— Invite: {inviteCode}
                                </button>
                                {isOwner && (
                                    <button 
                                        onClick={() => handleDeleteServer(id)}
                                        className="w-full text-left text-xs text-red-500 hover:text-red-400 transition"
                                    >
                                        ðŸ—‘ï¸ Delete Server
                                    </button>
                                )}
                            </div>
                        )}
                    </div>
                );
            };

            // Sidebar Channel Component
            const ChannelItem = ({ id, name, type, icon, onClick, isSelected, onEdit, onDelete }) => (
                <div className={`flex items-center justify-between p-2 rounded-lg transition ${isSelected ? 'bg-purple-700 text-white' : 'hover:bg-gray-700 text-gray-300'}`}>
                    <button onClick={() => onClick(id, type)} className="flex items-center flex-grow text-left">
                        <span className="mr-2 text-lg">{icon}</span>
                        <span className="truncate">{name}</span>
                    </button>
                    
                    {/* Edit Button for Category */}
                    {type === 'category' && (
                        <button onClick={onEdit} className="text-gray-400 hover:text-white transition ml-2 p-1 rounded-full hover:bg-gray-600" title="Edit Category">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                            </svg>
                        </button>
                    )}
                    
                    {/* Delete Button for Channel */}
                    {type === 'text' && onDelete && (
                        <button onClick={onDelete} className="text-gray-400 hover:text-red-400 transition ml-2 p-1 rounded-full hover:bg-gray-600" title="Delete Channel">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                            <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 10-2 0v6a1 1 0 102 0V8z" clipRule="evenodd" />
                            </svg>
                        </button>
                    )}
                </div>
            );


            // Main App UI
            return (
                <div className="min-h-screen bg-gray-900 text-gray-100 flex font-sans antialiased">
                    
                    {/* Server List Sidebar */}
                    <div className="w-20 bg-gray-900 p-3 flex flex-col items-center">
                        
                        {/* DMs Button */}
                        <ServerItem
                            id="DMs"
                            name="Direct Messages"
                            isSelected={currentServerId === 'DMs'}
                            onClick={selectServer}
                            handleDeleteServer={handleDeleteServer} // Pass dummy handler for DMs
                        />

                        <div className="w-full border-t border-gray-700 my-2"></div>

                        {/* Servers */}
                        {servers.map(server => (
                            <ServerItem
                                key={server.id}
                                id={server.id}
                                name={server.name}
                                isSelected={currentServerId === server.id}
                                onClick={selectServer}
                                isOwner={server.ownerId === userId}
                                inviteCode={server.inviteCode}
                                handleDeleteServer={handleDeleteServer}
                            />
                        ))}
                        
                        {/* Create Server */}
                        <button
                            onClick={() => setShowModal('createServer')}
                            title="Create Server"
                            className="w-14 h-14 mb-2 flex items-center justify-center text-green-400 text-2xl font-bold rounded-2xl bg-gray-700 hover:bg-green-500 hover:text-white transition-all duration-200"
                        >
                            +
                        </button>
                        
                        {/* Join Server */}
                        <button
                            onClick={() => setShowModal('joinServer')}
                            title="Join Server"
                            className="w-14 h-14 flex items-center justify-center text-blue-400 text-lg font-bold rounded-2xl bg-gray-700 hover:bg-blue-500 hover:text-white transition-all duration-200"
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a4 4 0 00-4-4H5a4 4 0 00-4 4v1h15zm0 0v-5a4 4 0 00-4-4H9a4 4 0 00-4 4v5" />
                            </svg>
                        </button>
                    </div>

                    {/* Channel List Sidebar */}
                    <div className="w-64 bg-gray-800 flex flex-col border-r border-gray-700">
                        
                        {/* Header/Server Name */}
                        <div className="p-4 border-b border-gray-700">
                            <h1 className="text-xl font-extrabold text-white truncate">
                                {currentServer?.name}
                            </h1>
                            <p className="text-sm text-gray-400 mt-1">
                                User: <button 
                                    onClick={() => setShowModal('profile')}
                                    className="text-purple-400 font-semibold hover:text-purple-300 transition"
                                >
                                    {userProfile?.displayName || 'Guest'}
                                </button>
                            </p>
                        </div>

                        {/* Channels/DMs List */}
                        <div className="flex-grow overflow-y-auto p-2 space-y-4">
                            
                            {currentServerId === 'DMs' ? (
                                <>
                                    <div className="text-sm font-semibold text-gray-400 p-2 flex justify-between items-center">
                                        DIRECT MESSAGES
                                        <button onClick={() => setShowModal('startDm')} className="text-purple-400 hover:text-purple-300 transition text-xl leading-none" title="Start New DM by Username">+</button>
                                    </div>
                                    <div className="space-y-1">
                                        {dmSessions.map(session => {
                                            const otherUserId = session.participants.find(id => id !== userId);
                                            const otherProfile = allProfiles[otherUserId];
                                            const dmName = otherProfile?.displayName || 'Unknown User';

                                            return (
                                                <ChannelItem
                                                    key={session.id}
                                                    id={session.id}
                                                    name={`@ ${dmName}`}
                                                    type="dm"
                                                    icon="ðŸ’¬"
                                                    isSelected={currentChannelId === session.id && currentChannelType === 'dm'}
                                                    onClick={selectChannel}
                                                />
                                            );
                                        })}
                                    </div>
                                </>
                            ) : (
                                <>
                                    <div className="text-sm font-semibold text-gray-400 p-2 pt-0 flex justify-between items-center">
                                        CHANNELS
                                        <div className="space-x-2">
                                            <button onClick={() => setShowModal('channel')} className="text-blue-400 hover:text-blue-300 transition text-xl leading-none" title="Create New Channel">+</button>
                                            <button onClick={() => openCategoryModal()} className="text-purple-400 hover:text-purple-300 transition text-xl leading-none" title="Create/Edit Categories">#</button>
                                        </div>
                                    </div>
                                    {categorizedChannels.map(category => (
                                        <div key={category.id}>
                                            <ChannelItem 
                                                id={category.id} 
                                                name={category.name.toUpperCase()}
                                                type="category"
                                                icon="ðŸ·ï¸"
                                                isSelected={false}
                                                onClick={() => {}}
                                                onEdit={() => openCategoryModal(category)}
                                            />
                                            <div className="pl-4 space-y-1 mt-1">
                                                {category.channels.map(channel => (
                                                    <ChannelItem
                                                        key={channel.id}
                                                        id={channel.id}
                                                        name={`# ${channel.name}`}
                                                        type="text"
                                                        icon=""
                                                        isSelected={currentChannelId === channel.id && currentChannelType === 'text'}
                                                        onClick={selectChannel}
                                                        onDelete={() => handleDeleteChannel(channel.id)}
                                                    />
                                                ))}
                                            </div>
                                        </div>
                                    ))}
                                </>
                            )}
                        </div>

                        {/* Footer (User ID Info) */}
                        <div className="p-4 border-t border-gray-700 text-xs text-gray-500 truncate">
                            Your UID: {userId}
                        </div>
                    </div>

                    {/* Main Chat Area */}
                    <div className="flex-grow flex flex-col">
                        
                        {/* Chat Header */}
                        <div className="p-4 bg-gray-800 border-b border-gray-700 shadow-md">
                            <h2 className="text-xl font-bold text-white">
                                {currentChannel ? currentChannel.name : 'Welcome'}
                            </h2>
                        </div>

                        {/* Messages Display */}
                        <div className="flex-grow overflow-y-auto p-4 space-y-4" id="message-container">
                            {messages.length === 0 ? (
                                <div className="text-center text-gray-500 mt-20">
                                    {currentChannelId ? `No messages yet in ${currentChannel?.name}. Send the first one!` : "Select a server/DM and a channel to start chatting."}
                                </div>
                            ) : (
                                messages.map((message) => {
                                    const senderProfile = allProfiles[message.userId] || { displayName: 'Anonymous', username: 'anon' };
                                    const timestamp = message.timestamp?.toDate ? message.timestamp.toDate().toLocaleTimeString() : '...';
                                    const isCurrentUser = message.userId === userId;

                                    return (
                                        <div key={message.id} className={`flex ${isCurrentUser ? 'justify-end' : 'justify-start'}`}>
                                            <div className={`flex items-start max-w-3/4 ${isCurrentUser ? 'flex-row-reverse' : 'flex-row'}`}>
                                                <div className="w-8 h-8 rounded-full bg-purple-600 flex items-center justify-center text-xs font-bold text-white flex-shrink-0">
                                                    {senderProfile.displayName[0]}
                                                </div>
                                                <div className={`p-3 rounded-xl shadow-md mx-3 ${isCurrentUser ? 'bg-purple-600 text-white rounded-tr-none' : 'bg-gray-700 text-gray-100 rounded-tl-none'}`}>
                                                    <div className="flex items-baseline">
                                                        <p className={`font-semibold text-sm ${isCurrentUser ? 'text-gray-200' : 'text-purple-400'}`}>
                                                            {senderProfile.displayName}
                                                        </p>
                                                        <span className="text-xs ml-2 text-gray-400">{timestamp}</span>
                                                    </div>
                                                    <p className="text-base break-words whitespace-pre-wrap">{message.text}</p>
                                                    {isCurrentUser && (
                                                        <button
                                                            onClick={() => deleteMessage(message.id)}
                                                            className="text-xs text-red-300 hover:text-red-500 mt-1 block transition"
                                                            title="Delete Message"
                                                        >
                                                            (Delete)
                                                        </button>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })
                            )}
                            {/* Auto-scroll to bottom of messages */}
                            <div ref={el => {
                                if (el) el.scrollIntoView({ behavior: 'smooth' });
                            }} />
                        </div>

                        {/* Message Input */}
                        <div className="p-4 bg-gray-800 border-t border-gray-700">
                            {currentChannelId ? (
                                <form onSubmit={sendMessage} className="flex space-x-3">
                                    <input
                                        type="text"
                                        value={newMessageText}
                                        onChange={(e) => setNewMessageText(e.target.value)}
                                        placeholder={`Message ${currentChannel.name}...`}
                                        className="flex-grow p-3 rounded-xl bg-gray-700 border border-gray-600 text-white focus:ring-purple-500 focus:border-purple-500 transition"
                                        disabled={!userProfile}
                                        required
                                    />
                                    <button
                                        type="submit"
                                        className={`px-6 py-3 rounded-xl font-semibold transition duration-150 shadow-lg ${userProfile ? 'bg-purple-600 hover:bg-purple-700 text-white' : 'bg-gray-600 text-gray-400 cursor-not-allowed'}`}
                                        disabled={!userProfile}
                                    >
                                        Send
                                    </button>
                                </form>
                            ) : (
                                <div className="text-center p-3 text-gray-400 border border-gray-700 rounded-xl">
                                    Please select a server/DM and a channel to begin messaging.
                                </div>
                            )}
                        </div>
                    </div>
                    
                    {/* Modals and Notifications */}
                    {showModal === 'login' && <AuthModal />}
                    {showModal === 'profile' && <ProfileModal />}
                    {showModal === 'category' && <CategoryModal />}
                    {showModal === 'channel' && <ChannelModal />}
                    {showModal === 'createServer' && <CreateServerModal />}
                    {showModal === 'joinServer' && <JoinServerModal />}
                    {showModal === 'startDm' && <StartDmModal />}

                    {notification && (
                        <ConfirmationMessage 
                            message={notification.message} 
                            type={notification.type} 
                            onClose={() => setNotification(null)} 
                        />
                    )}

                </div>
            );
        };

        // Wait for Firebase/global dependencies to load before rendering the App
        const renderApp = () => {
             ReactDOM.createRoot(document.getElementById('root')).render(<App />);
        };

        // Simple check to ensure required globals are loaded
        if (window.firebase) {
            renderApp();
        } else {
            window.addEventListener('load', renderApp);
        }

    </script>
</body>
</html>
